<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 新年倒计时</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            min-height: 100vh;
            background: #000;
            overflow: hidden;
            font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* 庆祝文字样式 */
        #celebration {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease;
        }

        #celebration.show {
            opacity: 1;
        }

        #celebration .year {
            font-size: clamp(80px, 15vw, 200px);
            font-weight: 900;
            background: linear-gradient(135deg, #ffd700 0%, #ffaa00 30%, #ff6600 60%, #ff3366 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 60px rgba(255, 170, 0, 0.5);
            filter: drop-shadow(0 0 30px rgba(255, 150, 0, 0.4));
            animation: yearPulse 2s ease-in-out infinite;
            letter-spacing: 10px;
        }

        #celebration .greeting {
            font-size: clamp(40px, 8vw, 100px);
            font-weight: 700;
            background: linear-gradient(90deg, #fff 0%, #ffd700 50%, #fff 100%);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 3s linear infinite;
            margin-top: 20px;
            letter-spacing: 15px;
        }

        @keyframes yearPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        /* 日期显示样式 */
        #dateDisplay {
            position: fixed;
            top: calc(50% - 120px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            font-size: clamp(32px, 6vw, 60px);
            font-weight: 600;
            letter-spacing: 12px;
            background: linear-gradient(
                90deg,
                rgba(255,255,255,0.6) 0%,
                rgba(255,255,255,0.9) 20%,
                rgba(255,215,180,1) 50%,
                rgba(255,255,255,0.9) 80%,
                rgba(255,255,255,0.6) 100%
            );
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: dateShimmer 6s ease-in-out infinite;
            filter: drop-shadow(0 0 15px rgba(255,220,180,0.3));
            transition: opacity 0.5s ease;
        }

        @keyframes dateShimmer {
            0%, 100% { background-position: 200% 0; }
            50% { background-position: -200% 0; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <!-- 倒计时日期显示 -->
    <div id="dateDisplay">2025年12月31日</div>

    <div id="celebration">
        <div class="year">2026</div>
        <div class="greeting">新年快乐</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const celebrationEl = document.getElementById('celebration');
        const dateDisplayEl = document.getElementById('dateDisplay');

        let W, H;
        let phase = 'countdown';
        let lastSec = -1;
        let needTransition = false;
        let currentDateStr = '';
        let currentTimeStr = '';

        function resize() {
            W = window.innerWidth;
            H = window.innerHeight;
            canvas.width = W;
            canvas.height = H;
        }
        resize();
        window.addEventListener('resize', resize);

        // ========== 配置 ==========
        const TIME_SPACING = 3;
        const TIME_SIZE = 1.5;
        const EXPLODE_FORCE = 2.5;
        const LERP_SPEED = 0.18;

        let simTime = 50;
        let lastTime = performance.now();

        // ========== 粒子系统 ==========
        const timeParticles = [];
        const freeParticles = [];

        function createParticle(x, y, tx, ty, size) {
            return {
                x, y, tx, ty,
                vx: 0, vy: 0,
                size: size + Math.random() * 0.3,
                exploding: false,
                free: false,
                life: 1
            };
        }

        function updateParticle(p, lerp = LERP_SPEED) {
            if (p.free) {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.02;
                p.life -= 0.006;
                return p.life > 0;
            }
            if (p.exploding) {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.93;
                p.vy *= 0.93;
                if (Math.abs(p.vx) < 0.08 && Math.abs(p.vy) < 0.08) {
                    p.exploding = false;
                }
            } else {
                p.x += (p.tx - p.x) * lerp;
                p.y += (p.ty - p.y) * lerp;
            }
            return true;
        }

        function drawParticle(p, color = '#fff') {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.free ? `rgba(255,255,255,${p.life})` : color;
            ctx.fill();
        }

        function explodeParticle(p) {
            p.exploding = true;
            const a = Math.random() * Math.PI * 2;
            const f = EXPLODE_FORCE + Math.random() * 2;
            p.vx = Math.cos(a) * f;
            p.vy = Math.sin(a) * f;
        }

        // ========== 文字转位置 ==========
        function getPositions(text, fontSize, cx, cy, spacing) {
            const offscreen = document.createElement('canvas');
            const octx = offscreen.getContext('2d');

            octx.font = `bold ${fontSize}px Arial, sans-serif`;
            const m = octx.measureText(text);
            const tw = Math.ceil(m.width) + 20;
            const th = fontSize + 20;

            offscreen.width = tw;
            offscreen.height = th;

            octx.font = `bold ${fontSize}px Arial, sans-serif`;
            octx.fillStyle = '#fff';
            octx.textAlign = 'center';
            octx.textBaseline = 'middle';
            octx.fillText(text, tw / 2, th / 2);

            const data = octx.getImageData(0, 0, tw, th).data;
            const result = [];
            const ox = cx - tw / 2;
            const oy = cy - th / 2;

            for (let y = 0; y < th; y += spacing) {
                for (let x = 0; x < tw; x += spacing) {
                    const i = (y * tw + x) * 4;
                    if (data[i + 3] > 100) {
                        result.push({ x: ox + x, y: oy + y });
                    }
                }
            }
            return result;
        }

        // ========== 年月日（CSS文字） ==========
        function updateDateDisplay() {
            const dateStr = simTime < 60 ? '2025年12月31日' : '2026年1月1日';
            if (dateStr !== currentDateStr) {
                currentDateStr = dateStr;
                dateDisplayEl.textContent = dateStr;
            }
        }

        // ========== 时分秒（动态） ==========
        function setTimeText(text, explode) {
            const fontSize = Math.min(W / 7, 120);
            const positions = getPositions(text, fontSize, W / 2, H / 2 + 40, TIME_SPACING);

            if (timeParticles.length === 0 || !explode) {
                timeParticles.length = 0;
                positions.forEach(pos => {
                    const p = createParticle(
                        W / 2 + (Math.random() - 0.5) * 50,
                        H / 2 + (Math.random() - 0.5) * 50,
                        pos.x, pos.y, TIME_SIZE
                    );
                    timeParticles.push(p);
                });
            } else {
                timeParticles.forEach(p => explodeParticle(p));

                while (timeParticles.length < positions.length) {
                    const p = createParticle(W / 2, H / 2 + 40, 0, 0, TIME_SIZE);
                    timeParticles.push(p);
                }
                while (timeParticles.length > positions.length) {
                    const p = timeParticles.pop();
                    p.free = true;
                    p.vx = (Math.random() - 0.5) * 3;
                    p.vy = -Math.random() * 2 - 1;
                    freeParticles.push(p);
                }

                positions.forEach((pos, i) => {
                    timeParticles[i].tx = pos.x;
                    timeParticles[i].ty = pos.y;
                });
            }
            currentTimeStr = text;
        }

        function explodeAllCountdown() {
            while (timeParticles.length > 0) {
                const p = timeParticles.pop();
                p.free = true;
                const a = Math.random() * Math.PI * 2;
                p.vx = Math.cos(a) * (2 + Math.random() * 3);
                p.vy = Math.sin(a) * (2 + Math.random() * 3);
                freeParticles.push(p);
            }
            // 隐藏日期显示
            dateDisplayEl.style.opacity = '0';
        }

        function formatTimeOnly(sec) {
            if (sec < 60) {
                return `23:59:${String(sec).padStart(2, '0')}`;
            } else {
                return `00:00:${String(sec - 60).padStart(2, '0')}`;
            }
        }

        // ========== 星空 ==========
        const stars = [];
        for (let i = 0; i < 120; i++) {
            stars.push({
                x: Math.random(), y: Math.random(),
                s: Math.random() * 1.5,
                p: Math.random() * Math.PI * 2
            });
        }

        function drawStars() {
            stars.forEach(st => {
                st.p += 0.008;
                const b = 0.15 + Math.sin(st.p) * 0.25;
                ctx.beginPath();
                ctx.arc(st.x * W, st.y * H, st.s, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255,255,255,${b})`;
                ctx.fill();
            });
        }

        // ========== 烟花系统 ==========
        const fireworks = [];

        function addFirework() {
            const colors = [
                'rgba(255,100,100,1)',
                'rgba(255,200,100,1)',
                'rgba(255,255,150,1)',
                'rgba(150,255,150,1)',
                'rgba(150,200,255,1)',
                'rgba(255,150,255,1)',
                'rgba(255,255,255,1)',
            ];
            fireworks.push({
                x: Math.random() * W,
                y: H + 10,
                vy: -5 - Math.random() * 14,
                color: colors[Math.floor(Math.random() * colors.length)],
                done: false,
                trail: [],
                particles: []
            });
        }

        function updateFireworks() {
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const f = fireworks[i];

                if (!f.done) {
                    f.trail.push({ x: f.x, y: f.y, a: 1 });
                    if (f.trail.length > 6) f.trail.shift();
                    f.y += f.vy;
                    f.vy += 0.06;

                    if (f.vy >= 0) {
                        f.done = true;
                        const count = 80 + Math.floor(Math.random() * 60);
                        for (let j = 0; j < count; j++) {
                            const a = Math.random() * Math.PI * 2;
                            const sp = 2 + Math.random() * 6;
                            f.particles.push({
                                x: f.x, y: f.y,
                                vx: Math.cos(a) * sp,
                                vy: Math.sin(a) * sp,
                                life: 1,
                                size: 2 + Math.random() * 2.5
                            });
                        }
                    }
                }

                f.trail = f.trail.filter(t => { t.a -= 0.06; return t.a > 0; });

                f.particles = f.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.03;
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    p.life -= 0.012;
                    return p.life > 0;
                });

                if (f.done && f.trail.length === 0 && f.particles.length === 0) {
                    fireworks.splice(i, 1);
                }
            }
        }

        function drawFireworks() {
            fireworks.forEach(f => {
                f.trail.forEach(t => {
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = f.color.replace('1)', `${t.a})`);
                    ctx.fill();
                });

                if (!f.done) {
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, 2, 0, Math.PI * 2);
                    ctx.fillStyle = f.color;
                    ctx.fill();
                }

                f.particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = f.color.replace('1)', `${p.life})`);
                    ctx.fill();
                });
            });
        }

        // ========== 主逻辑 ==========
        let fireworkTimer = 0;

        function update(dt) {
            simTime += dt / 1000;
            if (simTime >= 120) simTime = 0;

            const sec = Math.floor(simTime);
            const ms = (simTime - sec) * 1000;
            const isCountdown = sec < 60;

            fireworkTimer += dt;

            // 跨年
            if (phase === 'countdown' && !isCountdown) {
                phase = 'celebration';
                explodeAllCountdown();
                // 显示庆祝文字
                setTimeout(() => {
                    celebrationEl.classList.add('show');
                }, 500);
                // 大量烟花
                for (let i = 0; i < 20; i++) {
                    setTimeout(addFirework, i * 120);
                }
            }

            // 循环回倒计时
            if (phase === 'celebration' && isCountdown) {
                phase = 'countdown';
                lastSec = -1;
                currentDateStr = '';
                celebrationEl.classList.remove('show');

                setTimeout(() => {
                    dateDisplayEl.style.opacity = '1';
                    updateDateDisplay();
                    setTimeText(formatTimeOnly(sec), false);
                }, 400);
            }

            if (phase === 'countdown') {
                updateDateDisplay();

                const timeStr = formatTimeOnly(sec);

                if (timeParticles.length === 0) {
                    setTimeText(timeStr, false);
                    currentTimeStr = timeStr;
                    lastSec = sec;
                }

                if (sec !== lastSec) {
                    lastSec = sec;
                    needTransition = true;
                }

                if (needTransition && ms >= 800 && currentTimeStr !== timeStr) {
                    needTransition = false;
                    setTimeText(timeStr, true);
                }

                // 倒计时烟花
                if (fireworkTimer > 800) {
                    fireworkTimer = 0;
                    if (sec >= 50 && Math.random() < 0.6) {
                        addFirework();
                    } else if (Math.random() < 0.15) {
                        addFirework();
                    }
                }
            }

            if (phase === 'celebration') {
                // 庆祝烟花（很多）
                if (fireworkTimer > 150) {
                    fireworkTimer = 0;
                    if (Math.random() < 0.8) {
                        addFirework();
                    }
                }
            }
        }

        // ========== 渲染 ==========
        function loop(now) {
            const dt = now - lastTime;
            lastTime = now;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, W, H);

            drawStars();
            updateFireworks();
            drawFireworks();

            for (let i = freeParticles.length - 1; i >= 0; i--) {
                const p = freeParticles[i];
                if (!updateParticle(p)) {
                    freeParticles.splice(i, 1);
                } else {
                    drawParticle(p);
                }
            }

            timeParticles.forEach(p => {
                updateParticle(p);
                drawParticle(p, '#fff');
            });

            update(dt);
            requestAnimationFrame(loop);
        }

        requestAnimationFrame(loop);
    </script>
</body>
</html>
